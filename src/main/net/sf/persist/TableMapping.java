// $Id$

package net.sf.persist;

import java.lang.reflect.Method;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

/**
 * Holds mapping data from a given class and a table
 */
public final class TableMapping extends Mapping {

	private final Class objectClass;

	private final net.sf.persist.annotations.Table tableAnnotation;
	private final String tableName;

	private final String[] fields; // list of fields which have getters and setters
	private final Map<String, net.sf.persist.annotations.Column> annotationsMap; // maps field names to annotations
	private final Map<String, Method> gettersMap; // maps field names to getters
	private final Map<String, Method> settersMap; // maps field names to setters
    private final Map<String, Class> typesMap; // maps field names to data types

	private final boolean supportsGetGeneratedKeys;
	private final boolean supportsBatchUpdates;

	private final Map<String, String> columnsMap = new LinkedHashMap(); // maps table columns to field names
    private final Map<String, String> fieldsMap = new LinkedHashMap(); // maps field names to db column names
	private String[] columns;
//   private final String[] types;
	private final String[] primaryKeys;
	private final String[] notPrimaryKeys;
	private final String[] autoGeneratedColumns;
	private final String[] notAutoGeneratedColumns;

	private final String selectSql;
	private final String selectAllSql;
	private final String insertSql;
	private final String updateSql;
	private final String deleteSql;
    private final String createSql;

	public TableMapping(final DatabaseMetaData metaData, final Class objectClass, final NameGuesser nameGuesser)
			throws SQLException {
      this( metaData, objectClass, nameGuesser, null );
   }
   
   public TableMapping(final DatabaseMetaData metaData, final Class objectClass, final NameGuesser nameGuesser,
                       final String tableName )
			throws SQLException {
      this( metaData, objectClass, nameGuesser, tableName, false );
   }

   public TableMapping(final DatabaseMetaData metaData, final Class objectClass, final NameGuesser nameGuesser,
                          final String tableName, final boolean useGuessedNames )
			throws SQLException {

		ResultSet resultSet = null;

		// object class
		this.objectClass = objectClass;

		// database support for auto increment keys
		supportsGetGeneratedKeys = metaData.supportsGetGeneratedKeys();

		// database support for batch updates
		supportsBatchUpdates = metaData.supportsBatchUpdates();

		// database name
		final String databaseProductName = metaData.getDatabaseProductName();

		// table annotation
		tableAnnotation = (net.sf.persist.annotations.Table) objectClass
				.getAnnotation(net.sf.persist.annotations.Table.class);

		// schema pattern
		String schemaPattern = null;
		if (databaseProductName.equalsIgnoreCase("Oracle")) {
			schemaPattern = "%"; // oracle expects a pattern such as "%" to work
		}

        // table name and annotation
        if ( tableName == null )
           this.tableName = getTableName( metaData, schemaPattern, objectClass, nameGuesser, useGuessedNames );
        else {
           // in case we've been specified a table name
           String t = checkTableName( metaData, schemaPattern, tableName );

           // if checkTableName returns null, just use the name as given to us
           if ( t == null )
              this.tableName = tableName;
           else
              this.tableName = t;
        }

        // all column names and types (from db)
      // if the table does not exist, we'll skip this and assemble the column list later
		final List<String> columnsList = new ArrayList();
      if ( tableName != null ) {
		   resultSet = metaData.getColumns(null, schemaPattern, this.tableName, "%");
         while (resultSet.next()) {
			   final String columnName = resultSet.getString(4);
			   columnsList.add(columnName.toLowerCase(Locale.ENGLISH));
		   }
      }
		columns = toArray(columnsList);

		// all primary keys (from db)
      // again, if the table DNE, we'll figure this out later
		final List<String> primaryKeysList = new ArrayList();
      if ( tableName != null ) {
		   resultSet = metaData.getPrimaryKeys(null, schemaPattern, this.tableName);
		   while (resultSet.next()) {
			   final String columnName = resultSet.getString(4);
			   primaryKeysList.add(columnName.toLowerCase(Locale.ENGLISH));
		   }
      }

        // not primary keys

        final List<String> notPrimaryKeysList = new ArrayList();
		for (String columnName : columns) {
            if (!primaryKeysList.contains(columnName)) {
            	notPrimaryKeysList.add(columnName);
			}
		}
		// following line delayed until later
//      notPrimaryKeys = toArray( notPrimaryKeysList );

		// map field names to annotations, getters and setters

		final Map[] fieldsMaps = getFieldsMaps(objectClass);
		annotationsMap = fieldsMaps[0];
		gettersMap = fieldsMaps[1];
		settersMap = fieldsMaps[2];
        typesMap = fieldsMaps[3];
		fields = toArray(gettersMap.keySet());

        if ( Log.isDebugEnabled( Log.ENGINE ) ) {
            Log.debug( Log.ENGINE, "Table name " + tableName + " has fields " + gettersMap.keySet() );
        }

		// map column names to field names; create list of auto-increment columns
		// columnsMap use keys in lower case
        // also catch which columns have primaryKey annotations and add them to the PK list

		// the actual autoGeneratedColumns list should have columns in the database order
		final Set<String> autoGeneratedColumnsTemp = new HashSet();
		for (String fieldName : fields) {
			final String columnName = getColumnName(objectClass, nameGuesser, annotationsMap, columnsList, this.tableName,
					fieldName, useGuessedNames );
			columnsMap.put(columnName.toLowerCase(Locale.ENGLISH), fieldName);
            fieldsMap.put( fieldName, columnName );
			final net.sf.persist.annotations.Column annotation = annotationsMap.get(fieldName);
         if ( annotation != null ) {
            // if this field has an annotation marking it as autogenerated, add it to the autogenerated list
            if ( annotation.autoGenerated() ) {
				   autoGeneratedColumnsTemp.add(columnName);
//               autoGeneratedColumnsTemp.add(fieldName);
            }
            // if this field has an annotation marking it as a primary key and the PK list doesn't already contain it,
            // add it to the list of PKs and remove it from the list of "not PKs"
            if ( annotation.primaryKey() && !primaryKeysList.contains( columnName ) ) {
               primaryKeysList.add( columnName );
               // No need to check if the list contains this columnName already; if it does, this will remove it; if
               // it doesn't, this will not do anything.
               notPrimaryKeysList.remove( columnName );
            }
//            else if ( !notPrimaryKeysList.contains( columnName )) {
//               notPrimaryKeysList.add( columnName );
//            }
         }
		}

		// auto-increment and not-auto-increment columns, in the database order

      // if we're mapping an object that doesn't yet exist as a table, we will not have a
      // list of columns from the database, so we have to use the keys we created in the columnsMap (just above)
      if ( columns.length == 0 ) {
         columns = toArray( columnsMap.keySet() );
         if ( Log.isDebugEnabled( Log.ENGINE ) ) {
            Log.debug( Log.ENGINE, "Found no columns in the database, added the following columns from the columnsMap:\n  " + columnsMap.keySet() );
         }
      }
//      } else {
//         tempColumnsList = Arrays.asList( columns );
//      }

		final List<String> notAutoGeneratedColumnsList = new ArrayList();
		final List<String> autoGeneratedColumnsList = new ArrayList();
		for (String columnName : columns ) {
            // if column IS NOT in primary key list AND NOT in non-primary key list, add it
            if ( !primaryKeysList.contains( columnName ) && !notPrimaryKeysList.contains( columnName ) ) {
              notPrimaryKeysList.add( columnName );
            }

			if (autoGeneratedColumnsTemp.contains(columnName)) {
				autoGeneratedColumnsList.add(columnName);
			} else {
				notAutoGeneratedColumnsList.add(columnName);
			}
		}


      primaryKeys = toArray(primaryKeysList);
      notPrimaryKeys = toArray(notPrimaryKeysList);
      	notAutoGeneratedColumns = toArray(notAutoGeneratedColumnsList);
		autoGeneratedColumns = toArray(autoGeneratedColumnsList);

		// assemble sql blocks to be used by crud sql statements

		final String allColumns = join(columns, "", ",");
		final String noAutoColumns = join(notAutoGeneratedColumns, "", ",");
		final String allPlaceholders = multiply("?", columns.length, ",");
		final String noAutoPlaceholders = multiply("?", notAutoGeneratedColumns.length, ",");
		final String where = join(primaryKeys, "=?", " and ");
		final String updateSet = join(notPrimaryKeys, "=?", ",");

		// assemble crud sql statements

        String tName = "\"" + this.tableName + "\"";
		selectSql = "select " + allColumns + " from " + tName + " where " + where;
		selectAllSql = "select " + allColumns + " from " + tName;

		if (autoGeneratedColumns.length == 0) {
			insertSql = "insert into " + tName + "(" + allColumns + ")values(" + allPlaceholders + ")";
		} else {
			insertSql = "insert into " + tName + "(" + noAutoColumns + ")values(" + noAutoPlaceholders + ")";
		}

		updateSql = "update " + tName + " set " + updateSet + " where " + where;
		deleteSql = "delete from " + tName + " where " + where;

      // generate the create statement
      String tempSql = "create table " + tName + " ( ";
      for ( String columnName : columns ) {
          if ( Log.isDebugEnabled( Log.ENGINE ) ) {
            Log.debug( Log.ENGINE, "Retreiving columnsMap entry for column " + columnName );
            Log.debug( Log.ENGINE, "columnsMap entry for column " + columnName + " is " + columnsMap.get( columnName ) );
          }
          
         String type = typesMap.get( columnsMap.get( columnName ) ).getName();

         if ( Log.isDebugEnabled( Log.ENGINE ) ) {
            Log.debug( Log.ENGINE, "Java type [ " + type + " ] (for column " + columnName + " ) translates to" + " [ " +
                                   Persist.getTypeNameFromClass( typesMap.get( columnsMap.get( columnName ))) + " ]" );
         }

         tempSql += columnName + " " + Persist.getTypeNameFromClass( typesMap.get( columnsMap.get( columnName )));

         if ( autoGeneratedColumnsList.contains( columnName ))
            tempSql += " identity ";

         if ( primaryKeysList.contains( columnName ))
            tempSql += " primary key ";

         tempSql += ", ";
      }
      createSql = tempSql.substring( 0, tempSql.lastIndexOf( ", " )) + " ) ";

	}

	// ---------- getters and setters ----------

	public boolean supportsGetGeneratedKeys() {
		return supportsGetGeneratedKeys;
	}

	public boolean supportsBatchUpdates() {
		return supportsBatchUpdates;
	}

	public Class getObjectClass() {
		return objectClass;
	}

	public String getTableName() {
		return tableName;
	}

	public net.sf.persist.annotations.Table getTableAnnotation() {
		return tableAnnotation;
	}

    /**
     * @return a String array consisting of all of the column names for this object/table.  This is either read from the table metadata or created with the nameguesser.
     */
	public String[] getColumns() {
		return columns;
	}

    /**
     * @return a Map object with lowercase column names as keys and object field names as values
     */
	public Map<String, String> getColumnsMap() {
		return columnsMap;
	}

    /**
     * Given a method name, returns the associated column name in the db.
     * @param methodName any method name
     * @return the db column name associated with the given method name or null if the method name isn't associated with any columns
     */
    public String getColumnNameForMethod( String methodName ) {
        String fieldName = Mapping.extractFieldName( methodName );
        if ( fieldName != null )
            return fieldsMap.get( fieldName );
        else {
            if ( Log.isDebugEnabled( Log.ENGINE ) ) {
               Log.debug( Log.ENGINE, "Column names can only be returned for appropriate methods; method [ " + methodName + " ] is inappropriate." );
            }
            return null;
        }
    }

    /**
     * Returns the db column name associated with a particular field.
     * @param fieldName any field name
     * @return the db column name associated with the field name, or null if no column is associated with that field
     */
    public String getColumnNameForField( String fieldName ) {
        return fieldsMap.get( fieldName );
    }

	public String[] getPrimaryKeys() {
		return primaryKeys;
	}

	public String[] getNotPrimaryKeys() {
		return notPrimaryKeys;
	}

	public String[] getAutoGeneratedColumns() {
		return autoGeneratedColumns;
	}

	public String[] getNotAutoGeneratedColumns() {
		return notAutoGeneratedColumns;
	}

    /**
     * Returns a String array consisting of all of the valid field names for this object.
     * Valid fields are those for which there is a valid getter and setter.  The field name is
     * computed as the portion of the getter/setter method name which follows the characters "get", "set" or "is".
     *
     * @return a String array consisting of all of the valid field names for this object.
     */
	public String[] getFields() {
		return fields;
	}

    /**
     * @return a Map object with object field names as keys and db columns names as values
     */
	public Map<String, String> getFieldsMap() {
		return fieldsMap;
	}

    /**
     * @return a Map object with object field names as keys and Annotation objects as values
     */
	public Map<String, net.sf.persist.annotations.Column> getAnnotationsMap() {
		return annotationsMap;
	}

    /**
     * @return a Map object with object field names as keys and getter Method objects as values
     */
    public Map<String, Method> getGettersMap() {
		return gettersMap;
	}

    /**
     * @return a Map object with object field names as keys and setter Method objects as values
     */
	public Map<String, Method> getSettersMap() {
		return settersMap;
	}

	public Method getGetterForColumn(final String columnName) {
		final String fieldName = columnsMap.get(columnName.toLowerCase(Locale.ENGLISH));
		return gettersMap.get(fieldName);
	}

	public Method getSetterForColumn(final String columnName) {
		final String fieldName = columnsMap.get(columnName.toLowerCase(Locale.ENGLISH));
		return settersMap.get(fieldName);
	}

	public String getSelectSql() {
		return selectSql;
	}

	public String getSelectAllSql() {
		return selectAllSql;
	}

    /**
     * Generates an SQL statement which is ready to have a conditional statement appended to it.
     * The returned statement will have a rough format of "select ... where ".  (Note the " where " on the end, with spaces present.)
     * 
     * @return an SQL statement suitable for appending an conditional statement
     */
    public String getSelectWhereSql() {
        return selectAllSql + " where ";
    }

	public String getInsertSql() {
		return insertSql;
	}

	public String getUpdateSql() {
		return updateSql;
	}

	public String getDeleteSql() {
		return deleteSql;
	}

   public String getCreateSql() {
      return createSql;
   }

	// ---------- utility methods ----------

	private static String getTableName(final DatabaseMetaData metaData, final String schema, final Class objectClass,
			final NameGuesser nameGuesser) throws SQLException {
    return getTableName( metaData, schema, objectClass, nameGuesser, false );
   }

   private static String getTableName ( final DatabaseMetaData metaData, final String schema, final Class objectClass,
                                        final NameGuesser nameGuesser, final boolean useGuessedName )
         throws SQLException {

		String name = null;

		final net.sf.persist.annotations.Table tableAnnotation = (net.sf.persist.annotations.Table) objectClass
				.getAnnotation(net.sf.persist.annotations.Table.class);

		if (tableAnnotation != null && !tableAnnotation.name().equals("")) {
			// if there's a Table annotation, use it
			name = checkTableName(metaData, schema, tableAnnotation.name());

			// test if the specified table name actually exists
			if (name == null) {
               if ( useGuessedName ) {
                  name = tableAnnotation.name();
               } else {
                  throw new PersistException( "Class [" + objectClass.getName() + "] specifies table ["
						   + tableAnnotation.name() + "] that does not exist in the database");
               }
			}
		} else {
			// if no annotation, try guessed table names
			final String className = objectClass.getSimpleName().substring(0, 1).toLowerCase()
					+ objectClass.getSimpleName().substring(1);
			final Set<String> guessedNames = nameGuesser.guessColumn(className);
			for (String guessedTableName : guessedNames) {
				name = checkTableName(metaData, schema, guessedTableName);
				if (name != null) {
					break;
				}
			}
            if ( name == null ) {
             if ( useGuessedName )
                // just use the first guessed name
//                name = ((String[]) guessedNames.toArray())[0];
                 name = (String) guessedNames.toArray()[0];
             else
                throw new PersistException( "Class [" + objectClass.getName()
						+ "] does not specify a table name through a Table annotation and no guessed table names "
						+ guessedNames + " exist in the database");
			}
		}

		return name;
	}

	/**
	 * Check if the given name corresponds to a table in the database and
	 * returns the corresponding name with the capitalization returned by the
	 * database metadata.  Ie, the returned String will match the name of the table
     * as it is stored in the db.
	 */
	private static String checkTableName(final DatabaseMetaData metaData, final String schema, final String tableName)
			throws SQLException {

		ResultSet resultSet;
		String ret = null;

		// try name in upper case -- should work in most databases
		resultSet = metaData.getTables(null, schema, tableName.toUpperCase(Locale.ENGLISH), null);
		if (resultSet.next()) {
			ret = tableName.toUpperCase(Locale.ENGLISH);
		}
		resultSet.close();

		if (ret == null) {
			// try name in lower case
			resultSet = metaData.getTables(null, schema, tableName.toLowerCase(Locale.ENGLISH), null);
			if (resultSet.next()) {
				ret = tableName.toLowerCase(Locale.ENGLISH);
			}
			resultSet.close();
		}

		if (ret == null) {
			// last resort: compare with all table names in the schema 
			// (may be very expensive in databases such as oracle)
			// this may end up being used in databases that allow case sensitive names (such as postgresql)
			resultSet = metaData.getTables(null, schema, "%", null);
			while (resultSet.next()) {
				final String dbTableName = resultSet.getString(3);
				if (tableName.equalsIgnoreCase(dbTableName)) {
					ret = dbTableName;
					break;
				}
			}
			resultSet.close();
		}

		return ret;
	}

	private static String getColumnName(final Class objectClass, final NameGuesser nameGuesser,
			final Map<String, net.sf.persist.annotations.Column> annotationsMap, final List<String> columnsList,
			final String tableName, final String fieldName) throws SQLException {
      return getColumnName( objectClass, nameGuesser, annotationsMap, columnsList, tableName, fieldName, false );
   }

   private static String getColumnName( final Class objectClass,
                                        final NameGuesser nameGuesser,
                                        final Map<String, net.sf.persist.annotations.Column> annotationsMap,
                                        final List<String> columnsList,
                                        final String tableName,
                                        final String fieldName,
                                        final boolean useGuessedNames )
           throws SQLException {

		String columnName = null;

		final net.sf.persist.annotations.Column annotation = annotationsMap.get(fieldName);
		if (annotation != null && !annotation.name().equals("")) {
			// if there's an annotation, use it
			columnName = getIgnoreCase(columnsList, annotation.name());

			// check if the specified column actually exists in the table
			if (columnName == null) {
				throw new PersistException("Field [" + fieldName + "] from class [" + objectClass.getName()
						+ "] specifies column [" + annotation.name() + "] on table ["
						+ tableName.toLowerCase(Locale.ENGLISH) + "] that does not exist in the database");
			}
		} else {
			// if no annotation, try guessed column names
			final Set<String> guessedNames = nameGuesser.guessColumn(fieldName);

			for (String guessedColumnName : guessedNames) {
				columnName = getIgnoreCase(columnsList, guessedColumnName);
				if (columnName != null) {
					break;
				}
			}

			if (columnName == null) {
                if ( !useGuessedNames ) {
                    throw new PersistException( "Field [" + fieldName + "] from class [" + objectClass.getName()
					   	+ "] does not specify a column name through a Column annotation and no guessed column names "
					   	+ guessedNames + " exist in the database table [ " + tableName + " ]. If this field is not supposed to be associated "
				   		+ "with the database, please annotate it with @NoColumn");
                }
                else {
                    columnName = (String) guessedNames.toArray()[0];
                }
			}
		}

		return columnName;
	}

	// ---------- helpers ----------

	/**
	 * Returns the first entry from the provided collection that matches the
	 * provided string ignoring case during the comparison.
	 */
	private static String getIgnoreCase(final Collection<String> collection, final String str) {
		String ret = null;
		for (String s : collection) {
			if (s.equalsIgnoreCase(str)) {
				ret = s;
				break;
			}
		}
		return ret;
	}

	private static String[] toArray(final List<String> list) {
		String[] array = new String[list.size()];
		for (int i = 0; i < list.size(); i++) {
			array[i] = list.get(i);
		}
		return array;
	}

	private static String[] toArray(final Set<String> set) {
		final String[] array = new String[set.size()];
		int i = 0;
		for (String s : set) {
			array[i] = s;
			i++;
		}
		return array;
	}

	private static String join(final String[] list, final String suffix, final String separator) {
		final StringBuffer buf = new StringBuffer();
		for (String obj : list) {
			buf.append(obj.toString()).append(suffix).append(separator);
		}
		if (buf.length() > 0 && separator.length() > 0) {
			buf.delete(buf.length() - separator.length(), buf.length());
		}
		return buf.toString();
	}

	private static String multiply(final String str, final int times, final String separator) {
		final StringBuffer buf = new StringBuffer();
		for (int i = 0; i < times; i++) {
			buf.append(str).append(separator);
		}
		if (separator.length() > 0 && buf.length() > separator.length()) {
			buf.delete(buf.length() - separator.length(), buf.length());
		}
		return buf.toString();
	}

}
